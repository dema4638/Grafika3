<!DOCTYPE html>

<html>

<head>
  <title>Example 06.01 - Advanced 3D geometries - Convex Hull</title>
  <script type="text/javascript" src="three.js"></script>
  <script type="text/javascript" src="jquery-1.9.0.js"></script>
  <script type="text/javascript" src="TrackballControls.js"></script>
  <script type="text/javascript" src="stats.js"></script>
  <script type="text/javascript" src="dat.gui.js"></script>
  <script type="text/javascript" src="ConvexGeometry.js"></script>

  <style>
    body {
      /* set margin to 0 and overflow to hidden, to go fullscreen */
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>

  <div id="Stats-output">
  </div>
  <!-- Div which will hold the Output -->
  <div id="WebGL-output">
  </div>

  <!-- Javascript code that runs our Three.js examples -->
  <script type="text/javascript">
    // once everything is loaded, we run our Three.js stuff.
    $(function() {

      var stats = initStats();

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene();

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

      // create a render and set the size

      var webGLRenderer = new THREE.WebGLRenderer();
      webGLRenderer.setClearColorHex(0xEEEEEE, 1.0);
      webGLRenderer.setSize(window.innerWidth, window.innerHeight);
      webGLRenderer.shadowMapEnabled = true;
        $("#WebGL-output").append(webGLRenderer.domElement);
	    var trackballControls = new THREE.TrackballControls(camera, webGLRenderer.domElement);
      // position and point the camera to the center of the scene
      camera.position.x = -40;
      camera.position.y = 40;
      camera.position.z = 60;
      camera.lookAt(new THREE.Vector3(10, 0, 0));

      // add the output of the renderer to the html element
      $("#WebGL-output").append(webGLRenderer.domElement);

      // call the render function
      var step = 0;

      // the points group
      var spGroup;
      // the mesh
      var hullMesh;

      generatePoints();

      // setup the control gui
      var controls = new function() {
        // we need the first child, since it's a multimaterial

        this.redraw = function() {
          scene.remove(spGroup);
          scene.remove(hullMesh);
          scene.remove(bullMesh);
          generatePoints();

        };

      }

      var gui = new dat.GUI();
      gui.add(controls, 'redraw');


      render();

      function generatePoints() {
        // add 10 random spheres
        var points = [];
        var uvs = [];
        var c = 0;
        var h = 40;
        var R = 10;
        var R1 = 20;
        var R2 = 5;
        var change = (R1 - R2) / h;
        var m = ((R1 - R2) * (R1 - R2)) / (h * h);
        //var m = (R1-R2)^2/(h^2);
        var d = (h / 2) * (R1 + R2) / (R1 - R2);
        for (var i = 0; i < 3000; i++) {

          //  var randomX = -R1 + (Math.random() * 2*R1);
          var randomY = (Math.random() * h) - (h / 2);
          // var m = ((R1-R2)*(R1-R2))/ (randomY*randomY);
          // var d = (randomY/2)*(R1+R2)/(R1-R2);
          // var randomX = -R2 + (Math.random() * 2*R2);
          var randomX = ((Math.random() * (R1-(randomY*2 * change)))*2 - (R1-(randomY*2 * change)));
          // var randomX = 0;
         //var randomX = (Math.random() * (h - randomY) / h * R1 * 2 - ((h - randomY) / h * R1));

          var randomZ = (Math.random() * Math.sqrt(m * (randomY - d) * (randomY - d) - (randomX * randomX))) * 2 - Math.sqrt(m * (randomY - d) * (randomY - d) - (randomX * randomX));
          //  var randomZ = 0;
          if ((randomY >= (-h / 2)) && (randomY <= (h / 2)) && (randomX * randomX + randomZ * randomZ <= m * (randomY - d) * (randomY - d))) {
            points.push(new THREE.Vector3(randomX, randomY, randomZ));
            // var v = (((2 * randomY) / h) + 1) / 2;
            // var phi = Math.atan2(randomX, randomZ);
            // var u = phi / (2 * Math.PI);
            // uvs.push(new THREE.Vector2(u, v));
          }


        }

        spGroup = new THREE.Object3D();
        var material = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: false});
        points.forEach(function (point) {

            var spGeom = new THREE.SphereGeometry(0.2);
            var spMesh = new THREE.Mesh(spGeom, material);
            spMesh.position = point;
            spGroup.add(spMesh);
        });
      //  add the points as a group to the scene
        scene.add(spGroup);

        // use the same points to create a convexgeometry
        var hullGeometry = new THREE.ConvexGeometry(points);
        var texture = THREE.ImageUtils.loadTexture("https://i.imgur.com/1vRvlPv.png");
        var mat = new THREE.MeshBasicMaterial({
          map: texture
        });
        mat.side = THREE.DoubleSide;
        //hullMesh = createMesh(hullGeometry);
        var haha = addTexture(hullGeometry);
        hullMesh = new THREE.Mesh(haha, mat);
        scene.add(hullMesh);

        // spGroup = new THREE.Object3D();
        // var material = new THREE.MeshBasicMaterial({
        //   color: 0xff0000,
        //   transparent: false
        // });
        // points.forEach(function(point) {
        //
        //   var spGeom = new THREE.SphereGeometry(0.2);
        //   var spMesh = new THREE.Mesh(spGeom, material);
        //   spMesh.position = point;
        //   spGroup.add(spMesh);
        // });
        //
        // scene.add(spGroup);
        //scene.add(spMesh);

        // use the same points to create a convexgeometry
        var bulllGeometry = new THREE.ConvexGeometry(points);
        bullMesh = createMesh(hullGeometry);
        scene.add(bullMesh);
      }



      function createMesh(geom) {

        // assign two materials
        var meshMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.0
        });
        meshMaterial.side = THREE.DoubleSide;
        var wireFrameMat = new THREE.MeshBasicMaterial();
        wireFrameMat.wireframe = true;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);

        return mesh;
      }

      function addTexture(geo) {

        //console.log(geo.faceVertexUvs)
        var len = geo.faces.length
        for (var i = 0; i < len; i++) {



          var piCon = 0
          //console.log(piCon)

          var uwuPoints = []
          var vertX = geo.vertices[geo.faces[i].a]
          var vertY = geo.vertices[geo.faces[i].b]
          var vertZ = geo.vertices[geo.faces[i].c]

          var v1 = (((2 * vertX.y) / 40) + 1) / 2;
          //var v1 = ((2 * vertX.y) /40);
          var u1 = (Math.atan2(vertX.x, vertX.z) + (Math.PI)) / (2 * Math.PI)
          //var u1 = (Math.atan2(vertX.x, vertX.z)) / (2 * Math.PI)

          var v2 = (((2 * vertY.y) / 40) + 1) / 2;
          //var v2 = ((2 * vertY.y) /40);
         var u2 = (Math.atan2(vertY.x, vertY.z) + (Math.PI)) / (2 * Math.PI)
        //  var u2 = (Math.atan2(vertY.x, vertY.z)) / (2 * Math.PI)

          var v3 = (((2 * vertZ.y) / 40) + 1) / 2;
          //  var v3 = ((2 * vertZ.y) /40);
          var u3 = (Math.atan2(vertZ.x, vertZ.z) + (Math.PI)) / (2 * Math.PI)
          //  var u3 = (Math.atan2(vertZ.x, vertZ.z)) / (2 * Math.PI)
          var err = 0.8
          var s = 0.8
          var m = 0.8


        // if(Math.abs(u1-u2 )>= err || Math.abs(u1-u3 )>= err || Math.abs(u3-u2 )>= err){
        //


              if ((u1 - u2) > err && (u1 - u3) > err) {
               //u1 = (u2 + u3) / 2;
               u1 = u1 - m;
              }


              if ((u2 - u1) > err && (u2 - u3) > err) {
                u2 = u2 - m;
              //u2 = (u1 + u3) / 2;
              }


              if ((u3 - u1) > err && (u3 - u2) > err) {
                u3 = u3 - m;
               //u3 = (u1 + u2) / 2;
              }


              if ((u2 - u1) > err && (u3 - u1) > err) {
                u1 = u1 + s;
              // u1 = (u2 + u3) / 2
              }
              if ((u1 - u2) > err && (u3 - u2) > err) {
                u2 = u2 + s;
            //  u2 = (u1 + u3) / 2;
              }
              if ((u1 - u3) > err && (u2 - u3) > err) {
                u3 = u3 + s;
             //u3 = (u1 + u2) / 2;
            }
        //
        //
        //     // console.log(u1, u2, u3);
           // /}


          console.log(u1, u2, u3);
          uwuPoints.push(new THREE.Vector2(u1, v1))
          uwuPoints.push(new THREE.Vector2(u2, v2))
          uwuPoints.push(new THREE.Vector2(u3, v3))
          geo.faceVertexUvs[0][i] = uwuPoints

        }

        return geo

      }

      function my_atan(y, x) {
        var temp = Math.atan2(y, x); //[-180 ; 180]
        var aTanFixed = (temp > 0 ? temp : (2.0 * Math.PI + temp)) //[0 ; 360]
        return aTanFixed;
      }



      function render() {
        stats.update();

        // spGroup.rotation.y = step;
        // bullMesh.rotation.y = step;
        // hullMesh.rotation.y = step += 0.01;


        // render using requestAnimationFrame
        requestAnimationFrame(render);
        webGLRenderer.render(scene, camera);
        trackballControls.update();
      }

      function initStats() {

        var stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        $("#Stats-output").append(stats.domElement);

        return stats;
      }
    });
  </script>
</body>

</html>
